{"ast":null,"code":"import { keyName, base } from 'w3c-keyname';\nimport { Plugin } from 'prosemirror-state';\nconst mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;\nfunction normalizeKeyName(name) {\n  let parts = name.split(/-(?!$)/),\n    result = parts[parts.length - 1];\n  if (result == \"Space\") result = \" \";\n  let alt, ctrl, shift, meta;\n  for (let i = 0; i < parts.length - 1; i++) {\n    let mod = parts[i];\n    if (/^(cmd|meta|m)$/i.test(mod)) meta = true;else if (/^a(lt)?$/i.test(mod)) alt = true;else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;else if (/^s(hift)?$/i.test(mod)) shift = true;else if (/^mod$/i.test(mod)) {\n      if (mac) meta = true;else ctrl = true;\n    } else throw new Error(\"Unrecognized modifier name: \" + mod);\n  }\n  if (alt) result = \"Alt-\" + result;\n  if (ctrl) result = \"Ctrl-\" + result;\n  if (meta) result = \"Meta-\" + result;\n  if (shift) result = \"Shift-\" + result;\n  return result;\n}\nfunction normalize(map) {\n  let copy = Object.create(null);\n  for (let prop in map) copy[normalizeKeyName(prop)] = map[prop];\n  return copy;\n}\nfunction modifiers(name, event) {\n  let shift = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (event.altKey) name = \"Alt-\" + name;\n  if (event.ctrlKey) name = \"Ctrl-\" + name;\n  if (event.metaKey) name = \"Meta-\" + name;\n  if (shift && event.shiftKey) name = \"Shift-\" + name;\n  return name;\n}\n/**\r\nCreate a keymap plugin for the given set of bindings.\r\n\r\nBindings should map key names to [command](https://prosemirror.net/docs/ref/#commands)-style\r\nfunctions, which will be called with `(EditorState, dispatch,\r\nEditorView)` arguments, and should return true when they've handled\r\nthe key. Note that the view argument isn't part of the command\r\nprotocol, but can be used as an escape hatch if a binding needs to\r\ndirectly interact with the UI.\r\n\r\nKey names may be strings like `\"Shift-Ctrl-Enter\"`—a key\r\nidentifier prefixed with zero or more modifiers. Key identifiers\r\nare based on the strings that can appear in\r\n[`KeyEvent.key`](https:developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).\r\nUse lowercase letters to refer to letter keys (or uppercase letters\r\nif you want shift to be held). You may use `\"Space\"` as an alias\r\nfor the `\" \"` name.\r\n\r\nModifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or\r\n`a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or\r\n`Meta-`) are recognized. For characters that are created by holding\r\nshift, the `Shift-` prefix is implied, and should not be added\r\nexplicitly.\r\n\r\nYou can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on\r\nother platforms.\r\n\r\nYou can add multiple keymap plugins to an editor. The order in\r\nwhich they appear determines their precedence (the ones early in\r\nthe array get to dispatch first).\r\n*/\nfunction keymap(bindings) {\n  return new Plugin({\n    props: {\n      handleKeyDown: keydownHandler(bindings)\n    }\n  });\n}\n/**\r\nGiven a set of bindings (using the same format as\r\n[`keymap`](https://prosemirror.net/docs/ref/#keymap.keymap)), return a [keydown\r\nhandler](https://prosemirror.net/docs/ref/#view.EditorProps.handleKeyDown) that handles them.\r\n*/\nfunction keydownHandler(bindings) {\n  let map = normalize(bindings);\n  return function (view, event) {\n    let name = keyName(event),\n      baseName,\n      direct = map[modifiers(name, event)];\n    if (direct && direct(view.state, view.dispatch, view)) return true;\n    // A character key\n    if (name.length == 1 && name != \" \") {\n      if (event.shiftKey) {\n        // In case the name was already modified by shift, try looking\n        // it up without its shift modifier\n        let noShift = map[modifiers(name, event, false)];\n        if (noShift && noShift(view.state, view.dispatch, view)) return true;\n      }\n      if ((event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = base[event.keyCode]) && baseName != name) {\n        // Try falling back to the keyCode when there's a modifier\n        // active or the character produced isn't ASCII, and our table\n        // produces a different name from the the keyCode. See #668,\n        // #1060\n        let fromCode = map[modifiers(baseName, event)];\n        if (fromCode && fromCode(view.state, view.dispatch, view)) return true;\n      }\n    }\n    return false;\n  };\n}\nexport { keydownHandler, keymap };","map":{"version":3,"names":["keyName","base","Plugin","mac","navigator","test","platform","normalizeKeyName","name","parts","split","result","length","alt","ctrl","shift","meta","i","mod","Error","normalize","map","copy","Object","create","prop","modifiers","event","arguments","undefined","altKey","ctrlKey","metaKey","shiftKey","keymap","bindings","props","handleKeyDown","keydownHandler","view","baseName","direct","state","dispatch","noShift","charCodeAt","keyCode","fromCode"],"sources":["C:/Users/Bo/Desktop/coding/codestates/my-app/seb42_main_007/client/node_modules/prosemirror-keymap/dist/index.js"],"sourcesContent":["import { keyName, base } from 'w3c-keyname';\r\nimport { Plugin } from 'prosemirror-state';\r\n\r\nconst mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;\r\nfunction normalizeKeyName(name) {\r\n    let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];\r\n    if (result == \"Space\")\r\n        result = \" \";\r\n    let alt, ctrl, shift, meta;\r\n    for (let i = 0; i < parts.length - 1; i++) {\r\n        let mod = parts[i];\r\n        if (/^(cmd|meta|m)$/i.test(mod))\r\n            meta = true;\r\n        else if (/^a(lt)?$/i.test(mod))\r\n            alt = true;\r\n        else if (/^(c|ctrl|control)$/i.test(mod))\r\n            ctrl = true;\r\n        else if (/^s(hift)?$/i.test(mod))\r\n            shift = true;\r\n        else if (/^mod$/i.test(mod)) {\r\n            if (mac)\r\n                meta = true;\r\n            else\r\n                ctrl = true;\r\n        }\r\n        else\r\n            throw new Error(\"Unrecognized modifier name: \" + mod);\r\n    }\r\n    if (alt)\r\n        result = \"Alt-\" + result;\r\n    if (ctrl)\r\n        result = \"Ctrl-\" + result;\r\n    if (meta)\r\n        result = \"Meta-\" + result;\r\n    if (shift)\r\n        result = \"Shift-\" + result;\r\n    return result;\r\n}\r\nfunction normalize(map) {\r\n    let copy = Object.create(null);\r\n    for (let prop in map)\r\n        copy[normalizeKeyName(prop)] = map[prop];\r\n    return copy;\r\n}\r\nfunction modifiers(name, event, shift = true) {\r\n    if (event.altKey)\r\n        name = \"Alt-\" + name;\r\n    if (event.ctrlKey)\r\n        name = \"Ctrl-\" + name;\r\n    if (event.metaKey)\r\n        name = \"Meta-\" + name;\r\n    if (shift && event.shiftKey)\r\n        name = \"Shift-\" + name;\r\n    return name;\r\n}\r\n/**\r\nCreate a keymap plugin for the given set of bindings.\r\n\r\nBindings should map key names to [command](https://prosemirror.net/docs/ref/#commands)-style\r\nfunctions, which will be called with `(EditorState, dispatch,\r\nEditorView)` arguments, and should return true when they've handled\r\nthe key. Note that the view argument isn't part of the command\r\nprotocol, but can be used as an escape hatch if a binding needs to\r\ndirectly interact with the UI.\r\n\r\nKey names may be strings like `\"Shift-Ctrl-Enter\"`—a key\r\nidentifier prefixed with zero or more modifiers. Key identifiers\r\nare based on the strings that can appear in\r\n[`KeyEvent.key`](https:developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).\r\nUse lowercase letters to refer to letter keys (or uppercase letters\r\nif you want shift to be held). You may use `\"Space\"` as an alias\r\nfor the `\" \"` name.\r\n\r\nModifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or\r\n`a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or\r\n`Meta-`) are recognized. For characters that are created by holding\r\nshift, the `Shift-` prefix is implied, and should not be added\r\nexplicitly.\r\n\r\nYou can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on\r\nother platforms.\r\n\r\nYou can add multiple keymap plugins to an editor. The order in\r\nwhich they appear determines their precedence (the ones early in\r\nthe array get to dispatch first).\r\n*/\r\nfunction keymap(bindings) {\r\n    return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });\r\n}\r\n/**\r\nGiven a set of bindings (using the same format as\r\n[`keymap`](https://prosemirror.net/docs/ref/#keymap.keymap)), return a [keydown\r\nhandler](https://prosemirror.net/docs/ref/#view.EditorProps.handleKeyDown) that handles them.\r\n*/\r\nfunction keydownHandler(bindings) {\r\n    let map = normalize(bindings);\r\n    return function (view, event) {\r\n        let name = keyName(event), baseName, direct = map[modifiers(name, event)];\r\n        if (direct && direct(view.state, view.dispatch, view))\r\n            return true;\r\n        // A character key\r\n        if (name.length == 1 && name != \" \") {\r\n            if (event.shiftKey) {\r\n                // In case the name was already modified by shift, try looking\r\n                // it up without its shift modifier\r\n                let noShift = map[modifiers(name, event, false)];\r\n                if (noShift && noShift(view.state, view.dispatch, view))\r\n                    return true;\r\n            }\r\n            if ((event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) &&\r\n                (baseName = base[event.keyCode]) && baseName != name) {\r\n                // Try falling back to the keyCode when there's a modifier\r\n                // active or the character produced isn't ASCII, and our table\r\n                // produces a different name from the the keyCode. See #668,\r\n                // #1060\r\n                let fromCode = map[modifiers(baseName, event)];\r\n                if (fromCode && fromCode(view.state, view.dispatch, view))\r\n                    return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n}\r\n\r\nexport { keydownHandler, keymap };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}