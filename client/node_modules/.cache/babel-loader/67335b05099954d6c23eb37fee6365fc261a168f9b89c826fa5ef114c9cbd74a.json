{"ast":null,"code":"import RopeSequence from 'rope-sequence';\nimport { Mapping } from 'prosemirror-transform';\nimport { PluginKey, Plugin } from 'prosemirror-state';\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' — a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n// Used to schedule history compression\nconst max_empty_items = 500;\nclass Branch {\n  constructor(items, eventCount) {\n    this.items = items;\n    this.eventCount = eventCount;\n  }\n  // Pop the latest event off the branch's history and apply it\n  // to a document transform.\n  popEvent(state, preserveItems) {\n    if (this.eventCount == 0) return null;\n    let end = this.items.length;\n    for (;; end--) {\n      let next = this.items.get(end - 1);\n      if (next.selection) {\n        --end;\n        break;\n      }\n    }\n    let remap, mapFrom;\n    if (preserveItems) {\n      remap = this.remapping(end, this.items.length);\n      mapFrom = remap.maps.length;\n    }\n    let transform = state.tr;\n    let selection, remaining;\n    let addAfter = [],\n      addBefore = [];\n    this.items.forEach((item, i) => {\n      if (!item.step) {\n        if (!remap) {\n          remap = this.remapping(end, i + 1);\n          mapFrom = remap.maps.length;\n        }\n        mapFrom--;\n        addBefore.push(item);\n        return;\n      }\n      if (remap) {\n        addBefore.push(new Item(item.map));\n        let step = item.step.map(remap.slice(mapFrom)),\n          map;\n        if (step && transform.maybeStep(step).doc) {\n          map = transform.mapping.maps[transform.mapping.maps.length - 1];\n          addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));\n        }\n        mapFrom--;\n        if (map) remap.appendMap(map, mapFrom);\n      } else {\n        transform.maybeStep(item.step);\n      }\n      if (item.selection) {\n        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n        remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);\n        return false;\n      }\n    }, this.items.length, 0);\n    return {\n      remaining: remaining,\n      transform,\n      selection: selection\n    };\n  }\n  // Create a new branch with the given transform added.\n  addTransform(transform, selection, histOptions, preserveItems) {\n    let newItems = [],\n      eventCount = this.eventCount;\n    let oldItems = this.items,\n      lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n    for (let i = 0; i < transform.steps.length; i++) {\n      let step = transform.steps[i].invert(transform.docs[i]);\n      let item = new Item(transform.mapping.maps[i], step, selection),\n        merged;\n      if (merged = lastItem && lastItem.merge(item)) {\n        item = merged;\n        if (i) newItems.pop();else oldItems = oldItems.slice(0, oldItems.length - 1);\n      }\n      newItems.push(item);\n      if (selection) {\n        eventCount++;\n        selection = undefined;\n      }\n      if (!preserveItems) lastItem = item;\n    }\n    let overflow = eventCount - histOptions.depth;\n    if (overflow > DEPTH_OVERFLOW) {\n      oldItems = cutOffEvents(oldItems, overflow);\n      eventCount -= overflow;\n    }\n    return new Branch(oldItems.append(newItems), eventCount);\n  }\n  remapping(from, to) {\n    let maps = new Mapping();\n    this.items.forEach((item, i) => {\n      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from ? maps.maps.length - item.mirrorOffset : undefined;\n      maps.appendMap(item.map, mirrorPos);\n    }, from, to);\n    return maps;\n  }\n  addMaps(array) {\n    if (this.eventCount == 0) return this;\n    return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount);\n  }\n  // When the collab module receives remote changes, the history has\n  // to know about those, so that it can adjust the steps that were\n  // rebased on top of the remote changes, and include the position\n  // maps for the remote changes in its array of items.\n  rebased(rebasedTransform, rebasedCount) {\n    if (!this.eventCount) return this;\n    let rebasedItems = [],\n      start = Math.max(0, this.items.length - rebasedCount);\n    let mapping = rebasedTransform.mapping;\n    let newUntil = rebasedTransform.steps.length;\n    let eventCount = this.eventCount;\n    this.items.forEach(item => {\n      if (item.selection) eventCount--;\n    }, start);\n    let iRebased = rebasedCount;\n    this.items.forEach(item => {\n      let pos = mapping.getMirror(--iRebased);\n      if (pos == null) return;\n      newUntil = Math.min(newUntil, pos);\n      let map = mapping.maps[pos];\n      if (item.step) {\n        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n        if (selection) eventCount++;\n        rebasedItems.push(new Item(map, step, selection));\n      } else {\n        rebasedItems.push(new Item(map));\n      }\n    }, start);\n    let newMaps = [];\n    for (let i = rebasedCount; i < newUntil; i++) newMaps.push(new Item(mapping.maps[i]));\n    let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n    let branch = new Branch(items, eventCount);\n    if (branch.emptyItemCount() > max_empty_items) branch = branch.compress(this.items.length - rebasedItems.length);\n    return branch;\n  }\n  emptyItemCount() {\n    let count = 0;\n    this.items.forEach(item => {\n      if (!item.step) count++;\n    });\n    return count;\n  }\n  // Compressing a branch means rewriting it to push the air (map-only\n  // items) out. During collaboration, these naturally accumulate\n  // because each remote change adds one. The `upto` argument is used\n  // to ensure that only the items below a given level are compressed,\n  // because `rebased` relies on a clean, untouched set of items in\n  // order to associate old items with rebased steps.\n  compress() {\n    let upto = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items.length;\n    let remap = this.remapping(0, upto),\n      mapFrom = remap.maps.length;\n    let items = [],\n      events = 0;\n    this.items.forEach((item, i) => {\n      if (i >= upto) {\n        items.push(item);\n        if (item.selection) events++;\n      } else if (item.step) {\n        let step = item.step.map(remap.slice(mapFrom)),\n          map = step && step.getMap();\n        mapFrom--;\n        if (map) remap.appendMap(map, mapFrom);\n        if (step) {\n          let selection = item.selection && item.selection.map(remap.slice(mapFrom));\n          if (selection) events++;\n          let newItem = new Item(map.invert(), step, selection),\n            merged,\n            last = items.length - 1;\n          if (merged = items.length && items[last].merge(newItem)) items[last] = merged;else items.push(newItem);\n        }\n      } else if (item.map) {\n        mapFrom--;\n      }\n    }, this.items.length, 0);\n    return new Branch(RopeSequence.from(items.reverse()), events);\n  }\n}\nBranch.empty = new Branch(RopeSequence.empty, 0);\nfunction cutOffEvents(items, n) {\n  let cutPoint;\n  items.forEach((item, i) => {\n    if (item.selection && n-- == 0) {\n      cutPoint = i;\n      return false;\n    }\n  });\n  return items.slice(cutPoint);\n}\nclass Item {\n  constructor(\n  // The (forward) step map for this item.\n  map,\n  // The inverted step\n  step,\n  // If this is non-null, this item is the start of a group, and\n  // this selection is the starting selection for the group (the one\n  // that was active before the first step was applied)\n  selection,\n  // If this item is the inverse of a previous mapping on the stack,\n  // this points at the inverse's offset\n  mirrorOffset) {\n    this.map = map;\n    this.step = step;\n    this.selection = selection;\n    this.mirrorOffset = mirrorOffset;\n  }\n  merge(other) {\n    if (this.step && other.step && !other.selection) {\n      let step = other.step.merge(this.step);\n      if (step) return new Item(step.getMap().invert(), step, this.selection);\n    }\n  }\n}\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nclass HistoryState {\n  constructor(done, undone, prevRanges, prevTime) {\n    this.done = done;\n    this.undone = undone;\n    this.prevRanges = prevRanges;\n    this.prevTime = prevTime;\n  }\n}\nconst DEPTH_OVERFLOW = 20;\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n  let historyTr = tr.getMeta(historyKey),\n    rebased;\n  if (historyTr) return historyTr.historyState;\n  if (tr.getMeta(closeHistoryKey)) history = new HistoryState(history.done, history.undone, null, 0);\n  let appended = tr.getMeta(\"appendedTransaction\");\n  if (tr.steps.length == 0) {\n    return history;\n  } else if (appended && appended.getMeta(historyKey)) {\n    if (appended.getMeta(historyKey).redo) return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime);else return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime);\n  } else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n    // Group transforms that occur in quick succession into one event.\n    let newGroup = history.prevTime == 0 || !appended && (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges));\n    let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);\n    return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time);\n  } else if (rebased = tr.getMeta(\"rebased\")) {\n    // Used by the collab module to tell the history that some of its\n    // content has been rebased.\n    return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime);\n  } else {\n    return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime);\n  }\n}\nfunction isAdjacentTo(transform, prevRanges) {\n  if (!prevRanges) return false;\n  if (!transform.docChanged) return true;\n  let adjacent = false;\n  transform.mapping.maps[0].forEach((start, end) => {\n    for (let i = 0; i < prevRanges.length; i += 2) if (start <= prevRanges[i + 1] && end >= prevRanges[i]) adjacent = true;\n  });\n  return adjacent;\n}\nfunction rangesFor(map) {\n  let result = [];\n  map.forEach((_from, _to, from, to) => result.push(from, to));\n  return result;\n}\nfunction mapRanges(ranges, mapping) {\n  if (!ranges) return null;\n  let result = [];\n  for (let i = 0; i < ranges.length; i += 2) {\n    let from = mapping.map(ranges[i], 1),\n      to = mapping.map(ranges[i + 1], -1);\n    if (from <= to) result.push(from, to);\n  }\n  return result;\n}\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, dispatch, redo) {\n  let preserveItems = mustPreserveItems(state);\n  let histOptions = historyKey.get(state).spec.config;\n  let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n  if (!pop) return;\n  let selection = pop.selection.resolve(pop.transform.doc);\n  let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n  let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0);\n  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, {\n    redo,\n    historyState: newHist\n  }).scrollIntoView());\n}\nlet cachedPreserveItems = false,\n  cachedPreserveItemsPlugins = null;\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n  let plugins = state.plugins;\n  if (cachedPreserveItemsPlugins != plugins) {\n    cachedPreserveItems = false;\n    cachedPreserveItemsPlugins = plugins;\n    for (let i = 0; i < plugins.length; i++) if (plugins[i].spec.historyPreserveItems) {\n      cachedPreserveItems = true;\n      break;\n    }\n  }\n  return cachedPreserveItems;\n}\n/**\r\nSet a flag on the given transaction that will prevent further steps\r\nfrom being appended to an existing history event (so that they\r\nrequire a separate undo command to undo).\r\n*/\nfunction closeHistory(tr) {\n  return tr.setMeta(closeHistoryKey, true);\n}\nconst historyKey = new PluginKey(\"history\");\nconst closeHistoryKey = new PluginKey(\"closeHistory\");\n/**\r\nReturns a plugin that enables the undo history for an editor. The\r\nplugin will track undo and redo stacks, which can be used with the\r\n[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.\r\n\r\nYou can set an `\"addToHistory\"` [metadata\r\nproperty](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction\r\nto prevent it from being rolled back by undo.\r\n*/\nfunction history() {\n  let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  config = {\n    depth: config.depth || 100,\n    newGroupDelay: config.newGroupDelay || 500\n  };\n  return new Plugin({\n    key: historyKey,\n    state: {\n      init() {\n        return new HistoryState(Branch.empty, Branch.empty, null, 0);\n      },\n      apply(tr, hist, state) {\n        return applyTransaction(hist, state, tr, config);\n      }\n    },\n    config,\n    props: {\n      handleDOMEvents: {\n        beforeinput(view, e) {\n          let inputType = e.inputType;\n          let command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\n          if (!command) return false;\n          e.preventDefault();\n          return command(view.state, view.dispatch);\n        }\n      }\n    }\n  });\n}\n/**\r\nA command function that undoes the last change, if any.\r\n*/\nconst undo = (state, dispatch) => {\n  let hist = historyKey.getState(state);\n  if (!hist || hist.done.eventCount == 0) return false;\n  if (dispatch) histTransaction(hist, state, dispatch, false);\n  return true;\n};\n/**\r\nA command function that redoes the last undone change, if any.\r\n*/\nconst redo = (state, dispatch) => {\n  let hist = historyKey.getState(state);\n  if (!hist || hist.undone.eventCount == 0) return false;\n  if (dispatch) histTransaction(hist, state, dispatch, true);\n  return true;\n};\n/**\r\nThe amount of undoable events available in a given state.\r\n*/\nfunction undoDepth(state) {\n  let hist = historyKey.getState(state);\n  return hist ? hist.done.eventCount : 0;\n}\n/**\r\nThe amount of redoable events available in a given editor state.\r\n*/\nfunction redoDepth(state) {\n  let hist = historyKey.getState(state);\n  return hist ? hist.undone.eventCount : 0;\n}\nexport { closeHistory, history, redo, redoDepth, undo, undoDepth };","map":{"version":3,"names":["RopeSequence","Mapping","PluginKey","Plugin","max_empty_items","Branch","constructor","items","eventCount","popEvent","state","preserveItems","end","length","next","get","selection","remap","mapFrom","remapping","maps","transform","tr","remaining","addAfter","addBefore","forEach","item","i","step","push","Item","map","slice","maybeStep","doc","mapping","undefined","appendMap","append","reverse","concat","addTransform","histOptions","newItems","oldItems","lastItem","steps","invert","docs","merged","merge","pop","overflow","depth","DEPTH_OVERFLOW","cutOffEvents","from","to","mirrorPos","mirrorOffset","addMaps","array","rebased","rebasedTransform","rebasedCount","rebasedItems","start","Math","max","newUntil","iRebased","pos","getMirror","min","newMaps","branch","emptyItemCount","compress","count","upto","arguments","events","getMap","newItem","last","empty","n","cutPoint","other","HistoryState","done","undone","prevRanges","prevTime","applyTransaction","history","options","historyTr","getMeta","historyKey","historyState","closeHistoryKey","appended","redo","mustPreserveItems","rangesFor","newGroup","time","newGroupDelay","isAdjacentTo","mapRanges","getBookmark","docChanged","adjacent","result","_from","_to","ranges","histTransaction","dispatch","spec","config","resolve","added","newHist","setSelection","setMeta","scrollIntoView","cachedPreserveItems","cachedPreserveItemsPlugins","plugins","historyPreserveItems","closeHistory","key","init","apply","hist","props","handleDOMEvents","beforeinput","view","e","inputType","command","undo","preventDefault","getState","undoDepth","redoDepth"],"sources":["C:/Users/Bo/Desktop/coding/codestates/my-app/seb42_main_007/client/node_modules/prosemirror-history/dist/index.js"],"sourcesContent":["import RopeSequence from 'rope-sequence';\r\nimport { Mapping } from 'prosemirror-transform';\r\nimport { PluginKey, Plugin } from 'prosemirror-state';\r\n\r\n// ProseMirror's history isn't simply a way to roll back to a previous\r\n// state, because ProseMirror supports applying changes without adding\r\n// them to the history (for example during collaboration).\r\n//\r\n// To this end, each 'Branch' (one for the undo history and one for\r\n// the redo history) keeps an array of 'Items', which can optionally\r\n// hold a step (an actual undoable change), and always hold a position\r\n// map (which is needed to move changes below them to apply to the\r\n// current document).\r\n//\r\n// An item that has both a step and a selection bookmark is the start\r\n// of an 'event' — a group of changes that will be undone or redone at\r\n// once. (It stores only the bookmark, since that way we don't have to\r\n// provide a document until the selection is actually applied, which\r\n// is useful when compressing.)\r\n// Used to schedule history compression\r\nconst max_empty_items = 500;\r\nclass Branch {\r\n    constructor(items, eventCount) {\r\n        this.items = items;\r\n        this.eventCount = eventCount;\r\n    }\r\n    // Pop the latest event off the branch's history and apply it\r\n    // to a document transform.\r\n    popEvent(state, preserveItems) {\r\n        if (this.eventCount == 0)\r\n            return null;\r\n        let end = this.items.length;\r\n        for (;; end--) {\r\n            let next = this.items.get(end - 1);\r\n            if (next.selection) {\r\n                --end;\r\n                break;\r\n            }\r\n        }\r\n        let remap, mapFrom;\r\n        if (preserveItems) {\r\n            remap = this.remapping(end, this.items.length);\r\n            mapFrom = remap.maps.length;\r\n        }\r\n        let transform = state.tr;\r\n        let selection, remaining;\r\n        let addAfter = [], addBefore = [];\r\n        this.items.forEach((item, i) => {\r\n            if (!item.step) {\r\n                if (!remap) {\r\n                    remap = this.remapping(end, i + 1);\r\n                    mapFrom = remap.maps.length;\r\n                }\r\n                mapFrom--;\r\n                addBefore.push(item);\r\n                return;\r\n            }\r\n            if (remap) {\r\n                addBefore.push(new Item(item.map));\r\n                let step = item.step.map(remap.slice(mapFrom)), map;\r\n                if (step && transform.maybeStep(step).doc) {\r\n                    map = transform.mapping.maps[transform.mapping.maps.length - 1];\r\n                    addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));\r\n                }\r\n                mapFrom--;\r\n                if (map)\r\n                    remap.appendMap(map, mapFrom);\r\n            }\r\n            else {\r\n                transform.maybeStep(item.step);\r\n            }\r\n            if (item.selection) {\r\n                selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\r\n                remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);\r\n                return false;\r\n            }\r\n        }, this.items.length, 0);\r\n        return { remaining: remaining, transform, selection: selection };\r\n    }\r\n    // Create a new branch with the given transform added.\r\n    addTransform(transform, selection, histOptions, preserveItems) {\r\n        let newItems = [], eventCount = this.eventCount;\r\n        let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\r\n        for (let i = 0; i < transform.steps.length; i++) {\r\n            let step = transform.steps[i].invert(transform.docs[i]);\r\n            let item = new Item(transform.mapping.maps[i], step, selection), merged;\r\n            if (merged = lastItem && lastItem.merge(item)) {\r\n                item = merged;\r\n                if (i)\r\n                    newItems.pop();\r\n                else\r\n                    oldItems = oldItems.slice(0, oldItems.length - 1);\r\n            }\r\n            newItems.push(item);\r\n            if (selection) {\r\n                eventCount++;\r\n                selection = undefined;\r\n            }\r\n            if (!preserveItems)\r\n                lastItem = item;\r\n        }\r\n        let overflow = eventCount - histOptions.depth;\r\n        if (overflow > DEPTH_OVERFLOW) {\r\n            oldItems = cutOffEvents(oldItems, overflow);\r\n            eventCount -= overflow;\r\n        }\r\n        return new Branch(oldItems.append(newItems), eventCount);\r\n    }\r\n    remapping(from, to) {\r\n        let maps = new Mapping;\r\n        this.items.forEach((item, i) => {\r\n            let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from\r\n                ? maps.maps.length - item.mirrorOffset : undefined;\r\n            maps.appendMap(item.map, mirrorPos);\r\n        }, from, to);\r\n        return maps;\r\n    }\r\n    addMaps(array) {\r\n        if (this.eventCount == 0)\r\n            return this;\r\n        return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount);\r\n    }\r\n    // When the collab module receives remote changes, the history has\r\n    // to know about those, so that it can adjust the steps that were\r\n    // rebased on top of the remote changes, and include the position\r\n    // maps for the remote changes in its array of items.\r\n    rebased(rebasedTransform, rebasedCount) {\r\n        if (!this.eventCount)\r\n            return this;\r\n        let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);\r\n        let mapping = rebasedTransform.mapping;\r\n        let newUntil = rebasedTransform.steps.length;\r\n        let eventCount = this.eventCount;\r\n        this.items.forEach(item => { if (item.selection)\r\n            eventCount--; }, start);\r\n        let iRebased = rebasedCount;\r\n        this.items.forEach(item => {\r\n            let pos = mapping.getMirror(--iRebased);\r\n            if (pos == null)\r\n                return;\r\n            newUntil = Math.min(newUntil, pos);\r\n            let map = mapping.maps[pos];\r\n            if (item.step) {\r\n                let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\r\n                let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\r\n                if (selection)\r\n                    eventCount++;\r\n                rebasedItems.push(new Item(map, step, selection));\r\n            }\r\n            else {\r\n                rebasedItems.push(new Item(map));\r\n            }\r\n        }, start);\r\n        let newMaps = [];\r\n        for (let i = rebasedCount; i < newUntil; i++)\r\n            newMaps.push(new Item(mapping.maps[i]));\r\n        let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\r\n        let branch = new Branch(items, eventCount);\r\n        if (branch.emptyItemCount() > max_empty_items)\r\n            branch = branch.compress(this.items.length - rebasedItems.length);\r\n        return branch;\r\n    }\r\n    emptyItemCount() {\r\n        let count = 0;\r\n        this.items.forEach(item => { if (!item.step)\r\n            count++; });\r\n        return count;\r\n    }\r\n    // Compressing a branch means rewriting it to push the air (map-only\r\n    // items) out. During collaboration, these naturally accumulate\r\n    // because each remote change adds one. The `upto` argument is used\r\n    // to ensure that only the items below a given level are compressed,\r\n    // because `rebased` relies on a clean, untouched set of items in\r\n    // order to associate old items with rebased steps.\r\n    compress(upto = this.items.length) {\r\n        let remap = this.remapping(0, upto), mapFrom = remap.maps.length;\r\n        let items = [], events = 0;\r\n        this.items.forEach((item, i) => {\r\n            if (i >= upto) {\r\n                items.push(item);\r\n                if (item.selection)\r\n                    events++;\r\n            }\r\n            else if (item.step) {\r\n                let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();\r\n                mapFrom--;\r\n                if (map)\r\n                    remap.appendMap(map, mapFrom);\r\n                if (step) {\r\n                    let selection = item.selection && item.selection.map(remap.slice(mapFrom));\r\n                    if (selection)\r\n                        events++;\r\n                    let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1;\r\n                    if (merged = items.length && items[last].merge(newItem))\r\n                        items[last] = merged;\r\n                    else\r\n                        items.push(newItem);\r\n                }\r\n            }\r\n            else if (item.map) {\r\n                mapFrom--;\r\n            }\r\n        }, this.items.length, 0);\r\n        return new Branch(RopeSequence.from(items.reverse()), events);\r\n    }\r\n}\r\nBranch.empty = new Branch(RopeSequence.empty, 0);\r\nfunction cutOffEvents(items, n) {\r\n    let cutPoint;\r\n    items.forEach((item, i) => {\r\n        if (item.selection && (n-- == 0)) {\r\n            cutPoint = i;\r\n            return false;\r\n        }\r\n    });\r\n    return items.slice(cutPoint);\r\n}\r\nclass Item {\r\n    constructor(\r\n    // The (forward) step map for this item.\r\n    map, \r\n    // The inverted step\r\n    step, \r\n    // If this is non-null, this item is the start of a group, and\r\n    // this selection is the starting selection for the group (the one\r\n    // that was active before the first step was applied)\r\n    selection, \r\n    // If this item is the inverse of a previous mapping on the stack,\r\n    // this points at the inverse's offset\r\n    mirrorOffset) {\r\n        this.map = map;\r\n        this.step = step;\r\n        this.selection = selection;\r\n        this.mirrorOffset = mirrorOffset;\r\n    }\r\n    merge(other) {\r\n        if (this.step && other.step && !other.selection) {\r\n            let step = other.step.merge(this.step);\r\n            if (step)\r\n                return new Item(step.getMap().invert(), step, this.selection);\r\n        }\r\n    }\r\n}\r\n// The value of the state field that tracks undo/redo history for that\r\n// state. Will be stored in the plugin state when the history plugin\r\n// is active.\r\nclass HistoryState {\r\n    constructor(done, undone, prevRanges, prevTime) {\r\n        this.done = done;\r\n        this.undone = undone;\r\n        this.prevRanges = prevRanges;\r\n        this.prevTime = prevTime;\r\n    }\r\n}\r\nconst DEPTH_OVERFLOW = 20;\r\n// Record a transformation in undo history.\r\nfunction applyTransaction(history, state, tr, options) {\r\n    let historyTr = tr.getMeta(historyKey), rebased;\r\n    if (historyTr)\r\n        return historyTr.historyState;\r\n    if (tr.getMeta(closeHistoryKey))\r\n        history = new HistoryState(history.done, history.undone, null, 0);\r\n    let appended = tr.getMeta(\"appendedTransaction\");\r\n    if (tr.steps.length == 0) {\r\n        return history;\r\n    }\r\n    else if (appended && appended.getMeta(historyKey)) {\r\n        if (appended.getMeta(historyKey).redo)\r\n            return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime);\r\n        else\r\n            return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime);\r\n    }\r\n    else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\r\n        // Group transforms that occur in quick succession into one event.\r\n        let newGroup = history.prevTime == 0 || !appended && (history.prevTime < (tr.time || 0) - options.newGroupDelay ||\r\n            !isAdjacentTo(tr, history.prevRanges));\r\n        let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);\r\n        return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time);\r\n    }\r\n    else if (rebased = tr.getMeta(\"rebased\")) {\r\n        // Used by the collab module to tell the history that some of its\r\n        // content has been rebased.\r\n        return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime);\r\n    }\r\n    else {\r\n        return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime);\r\n    }\r\n}\r\nfunction isAdjacentTo(transform, prevRanges) {\r\n    if (!prevRanges)\r\n        return false;\r\n    if (!transform.docChanged)\r\n        return true;\r\n    let adjacent = false;\r\n    transform.mapping.maps[0].forEach((start, end) => {\r\n        for (let i = 0; i < prevRanges.length; i += 2)\r\n            if (start <= prevRanges[i + 1] && end >= prevRanges[i])\r\n                adjacent = true;\r\n    });\r\n    return adjacent;\r\n}\r\nfunction rangesFor(map) {\r\n    let result = [];\r\n    map.forEach((_from, _to, from, to) => result.push(from, to));\r\n    return result;\r\n}\r\nfunction mapRanges(ranges, mapping) {\r\n    if (!ranges)\r\n        return null;\r\n    let result = [];\r\n    for (let i = 0; i < ranges.length; i += 2) {\r\n        let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);\r\n        if (from <= to)\r\n            result.push(from, to);\r\n    }\r\n    return result;\r\n}\r\n// Apply the latest event from one branch to the document and shift the event\r\n// onto the other branch.\r\nfunction histTransaction(history, state, dispatch, redo) {\r\n    let preserveItems = mustPreserveItems(state);\r\n    let histOptions = historyKey.get(state).spec.config;\r\n    let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\r\n    if (!pop)\r\n        return;\r\n    let selection = pop.selection.resolve(pop.transform.doc);\r\n    let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\r\n    let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0);\r\n    dispatch(pop.transform.setSelection(selection).setMeta(historyKey, { redo, historyState: newHist }).scrollIntoView());\r\n}\r\nlet cachedPreserveItems = false, cachedPreserveItemsPlugins = null;\r\n// Check whether any plugin in the given state has a\r\n// `historyPreserveItems` property in its spec, in which case we must\r\n// preserve steps exactly as they came in, so that they can be\r\n// rebased.\r\nfunction mustPreserveItems(state) {\r\n    let plugins = state.plugins;\r\n    if (cachedPreserveItemsPlugins != plugins) {\r\n        cachedPreserveItems = false;\r\n        cachedPreserveItemsPlugins = plugins;\r\n        for (let i = 0; i < plugins.length; i++)\r\n            if (plugins[i].spec.historyPreserveItems) {\r\n                cachedPreserveItems = true;\r\n                break;\r\n            }\r\n    }\r\n    return cachedPreserveItems;\r\n}\r\n/**\r\nSet a flag on the given transaction that will prevent further steps\r\nfrom being appended to an existing history event (so that they\r\nrequire a separate undo command to undo).\r\n*/\r\nfunction closeHistory(tr) {\r\n    return tr.setMeta(closeHistoryKey, true);\r\n}\r\nconst historyKey = new PluginKey(\"history\");\r\nconst closeHistoryKey = new PluginKey(\"closeHistory\");\r\n/**\r\nReturns a plugin that enables the undo history for an editor. The\r\nplugin will track undo and redo stacks, which can be used with the\r\n[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.\r\n\r\nYou can set an `\"addToHistory\"` [metadata\r\nproperty](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction\r\nto prevent it from being rolled back by undo.\r\n*/\r\nfunction history(config = {}) {\r\n    config = { depth: config.depth || 100,\r\n        newGroupDelay: config.newGroupDelay || 500 };\r\n    return new Plugin({\r\n        key: historyKey,\r\n        state: {\r\n            init() {\r\n                return new HistoryState(Branch.empty, Branch.empty, null, 0);\r\n            },\r\n            apply(tr, hist, state) {\r\n                return applyTransaction(hist, state, tr, config);\r\n            }\r\n        },\r\n        config,\r\n        props: {\r\n            handleDOMEvents: {\r\n                beforeinput(view, e) {\r\n                    let inputType = e.inputType;\r\n                    let command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\r\n                    if (!command)\r\n                        return false;\r\n                    e.preventDefault();\r\n                    return command(view.state, view.dispatch);\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\n/**\r\nA command function that undoes the last change, if any.\r\n*/\r\nconst undo = (state, dispatch) => {\r\n    let hist = historyKey.getState(state);\r\n    if (!hist || hist.done.eventCount == 0)\r\n        return false;\r\n    if (dispatch)\r\n        histTransaction(hist, state, dispatch, false);\r\n    return true;\r\n};\r\n/**\r\nA command function that redoes the last undone change, if any.\r\n*/\r\nconst redo = (state, dispatch) => {\r\n    let hist = historyKey.getState(state);\r\n    if (!hist || hist.undone.eventCount == 0)\r\n        return false;\r\n    if (dispatch)\r\n        histTransaction(hist, state, dispatch, true);\r\n    return true;\r\n};\r\n/**\r\nThe amount of undoable events available in a given state.\r\n*/\r\nfunction undoDepth(state) {\r\n    let hist = historyKey.getState(state);\r\n    return hist ? hist.done.eventCount : 0;\r\n}\r\n/**\r\nThe amount of redoable events available in a given editor state.\r\n*/\r\nfunction redoDepth(state) {\r\n    let hist = historyKey.getState(state);\r\n    return hist ? hist.undone.eventCount : 0;\r\n}\r\n\r\nexport { closeHistory, history, redo, redoDepth, undo, undoDepth };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}